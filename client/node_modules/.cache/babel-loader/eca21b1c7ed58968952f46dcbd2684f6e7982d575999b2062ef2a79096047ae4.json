{"ast":null,"code":"import * as ActionTypes from '../ContextActions';\nexport default ((state, action) => {\n  switch (action.type) {\n    case ActionTypes.NEW_BLOG_SUCCESS:\n      let blogs = state.blogs ? state.blogs : []; //checks if the state.blogs array exists, and if not, sets it to an empty array.\n      return {\n        ...state,\n        blogCreated: true,\n        currentBlog: action.payload,\n        blogs: [...blogs, action.payload]\n      };\n    case ActionTypes.GET_BLOGS_SUCCESS:\n      return {\n        ...state,\n        blogs: action.payload\n      };\n    case ActionTypes.BLOG_FAIL:\n      return {\n        ...state,\n        blogs: action.payload\n      };\n    case ActionTypes.UPDATE_BLOG:\n      return {\n        ...state,\n        currentBlog: action.payload,\n        blogs: state.blogs.map(blog => blog._id === action.payload._id ? action.payload : blog) // we're going to iterate thru our state blogs,we're gonna look for the blog thru blog._id i.e we're going to compare what we have(blog._id) vs the payload that we return, if the ids match then we update that with the new payload otherwise we'll return the blog\n      };\n\n    case ActionTypes.BLOG_DELETE:\n      return {\n        ...state,\n        blogs: state.blogs.filter(blog => blog._id !== action.payload.blogId),\n        toasts: action.payload.toasts\n      };\n    case ActionTypes.GET_BLOG_BY_ID:\n      return {\n        ...state,\n        currentBlog: action.payload\n      };\n    case ActionTypes.CLEAR_ERRORS:\n      return {\n        ...state,\n        toasts: null\n      };\n    case ActionTypes.CLEAR_CURRENT_BLOG:\n      return {\n        ...state,\n        currentBlog: null\n      };\n    case ActionTypes.CLEAR_BLOGS:\n      return {\n        ...state,\n        blogs: null\n      };\n    default:\n      return state;\n  }\n});","map":{"version":3,"names":["ActionTypes","state","action","type","NEW_BLOG_SUCCESS","blogs","blogCreated","currentBlog","payload","GET_BLOGS_SUCCESS","BLOG_FAIL","UPDATE_BLOG","map","blog","_id","BLOG_DELETE","filter","blogId","toasts","GET_BLOG_BY_ID","CLEAR_ERRORS","CLEAR_CURRENT_BLOG","CLEAR_BLOGS"],"sources":["/home/rahul/Desktop/NewBlog/client/src/context/blog_context/blogReducer.js"],"sourcesContent":["import * as ActionTypes from '../ContextActions'\n\nexport default (state,action) => {\n    switch (action.type){\n        case ActionTypes.NEW_BLOG_SUCCESS:\n            let blogs = state.blogs ? state.blogs :[]; //checks if the state.blogs array exists, and if not, sets it to an empty array.\n            return{\n                ...state,\n                blogCreated: true,\n                currentBlog: action.payload,\n                blogs: [...blogs,action.payload]\n            }\n        case ActionTypes.GET_BLOGS_SUCCESS:\n                return{\n                    ...state,\n                    blogs: action.payload\n                }\n        case ActionTypes.BLOG_FAIL:\n                return{\n                        ...state,\n                        blogs: action.payload\n                    }\n        case ActionTypes.UPDATE_BLOG:\n                return{\n                            ...state,\n                            currentBlog: action.payload,\n                            blogs: state.blogs.map(blog => blog._id === action.payload._id ? action.payload: blog)// we're going to iterate thru our state blogs,we're gonna look for the blog thru blog._id i.e we're going to compare what we have(blog._id) vs the payload that we return, if the ids match then we update that with the new payload otherwise we'll return the blog\n                        }   \n                        \n        case ActionTypes.BLOG_DELETE:\n            return{\n                ...state,\n                blogs: state.blogs.filter(blog=> blog._id !== action.payload.blogId),\n                toasts: action.payload.toasts\n                \n            } \n            \n        case ActionTypes.GET_BLOG_BY_ID:\n            return{\n                ...state,\n                currentBlog: action.payload,\n\n            }    \n\n        case ActionTypes.CLEAR_ERRORS:\n            return{\n                ...state,\n                toasts: null\n            }  \n        case ActionTypes.CLEAR_CURRENT_BLOG:\n            return{\n                    ...state,\n                    currentBlog: null,\n                    \n                }     \n            \n        case ActionTypes.CLEAR_BLOGS:\n                return{\n                    ...state,\n                    blogs: null\n                }    \n                         \n                        \n        default :\n            return state;                \n\n\n    }\n}"],"mappings":"AAAA,OAAO,KAAKA,WAAW,MAAM,mBAAmB;AAEhD,gBAAe,CAACC,KAAK,EAACC,MAAM,KAAK;EAC7B,QAAQA,MAAM,CAACC,IAAI;IACf,KAAKH,WAAW,CAACI,gBAAgB;MAC7B,IAAIC,KAAK,GAAGJ,KAAK,CAACI,KAAK,GAAGJ,KAAK,CAACI,KAAK,GAAE,EAAE,CAAC,CAAC;MAC3C,OAAM;QACF,GAAGJ,KAAK;QACRK,WAAW,EAAE,IAAI;QACjBC,WAAW,EAAEL,MAAM,CAACM,OAAO;QAC3BH,KAAK,EAAE,CAAC,GAAGA,KAAK,EAACH,MAAM,CAACM,OAAO;MACnC,CAAC;IACL,KAAKR,WAAW,CAACS,iBAAiB;MAC1B,OAAM;QACF,GAAGR,KAAK;QACRI,KAAK,EAAEH,MAAM,CAACM;MAClB,CAAC;IACT,KAAKR,WAAW,CAACU,SAAS;MAClB,OAAM;QACE,GAAGT,KAAK;QACRI,KAAK,EAAEH,MAAM,CAACM;MAClB,CAAC;IACb,KAAKR,WAAW,CAACW,WAAW;MACpB,OAAM;QACM,GAAGV,KAAK;QACRM,WAAW,EAAEL,MAAM,CAACM,OAAO;QAC3BH,KAAK,EAAEJ,KAAK,CAACI,KAAK,CAACO,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,GAAG,KAAKZ,MAAM,CAACM,OAAO,CAACM,GAAG,GAAGZ,MAAM,CAACM,OAAO,GAAEK,IAAI,CAAC;MAC1F,CAAC;;IAEjB,KAAKb,WAAW,CAACe,WAAW;MACxB,OAAM;QACF,GAAGd,KAAK;QACRI,KAAK,EAAEJ,KAAK,CAACI,KAAK,CAACW,MAAM,CAACH,IAAI,IAAGA,IAAI,CAACC,GAAG,KAAKZ,MAAM,CAACM,OAAO,CAACS,MAAM,CAAC;QACpEC,MAAM,EAAEhB,MAAM,CAACM,OAAO,CAACU;MAE3B,CAAC;IAEL,KAAKlB,WAAW,CAACmB,cAAc;MAC3B,OAAM;QACF,GAAGlB,KAAK;QACRM,WAAW,EAAEL,MAAM,CAACM;MAExB,CAAC;IAEL,KAAKR,WAAW,CAACoB,YAAY;MACzB,OAAM;QACF,GAAGnB,KAAK;QACRiB,MAAM,EAAE;MACZ,CAAC;IACL,KAAKlB,WAAW,CAACqB,kBAAkB;MAC/B,OAAM;QACE,GAAGpB,KAAK;QACRM,WAAW,EAAE;MAEjB,CAAC;IAET,KAAKP,WAAW,CAACsB,WAAW;MACpB,OAAM;QACF,GAAGrB,KAAK;QACRI,KAAK,EAAE;MACX,CAAC;IAGT;MACI,OAAOJ,KAAK;EAAC;AAIzB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}